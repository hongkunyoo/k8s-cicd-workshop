# ArgoCD를 이용한 배포

## ArgoCD 설치

```bash
kubectl create namespace argocd
# namespace/argocd created

kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
# customresourcedefinition.apiextensions.k8s.io/applications.argoproj.io created
# customresourcedefinition.apiextensions.k8s.io/appprojects.argoproj.io created
# serviceaccount/argocd-application-controller created
# serviceaccount/argocd-dex-server created
# ...
```

ArgoCD 경우, tls 설정을 강제합니다. HTTP 프로토콜로 접속 시 강제로 HTTPS로 리다이렉트

```yaml
# argocd-ingress.yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: argocd
  namespace: argocd
  annotations:
    cert-manager.io/cluster-issuer: http-issuer
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/backend-protocol: HTTPS
    nginx.ingress.kubernetes.io/ssl-passthrough: "true"
spec:
  rules:
  - host: argocd.10.0.1.1.sslip.io
    http:
      paths:
      - path: /
        backend:
          serviceName: argocd-server
          servicePort: https
  tls:
  - hosts:
    - argocd.10.0.1.1.sslip.io
    secretName: argocd-tls
```

---

**참고** 

1. tls 설정을 하지 않는 경우 `--insecure` 옵션을 지정하여 피해갈 수도 있습니다. ([https://argoproj.github.io/argo-cd/operator-manual/ingress/#option-2-multiple-ingress-objects-and-hosts](https://argoproj.github.io/argo-cd/operator-manual/ingress/#option-2-multiple-ingress-objects-and-hosts))

	---

```bash
kubectl apply -f argocd-ingress.yaml
# ingress.networking.k8s.io/argocd created
```

- 아이디: admin
- 비밀번호: 다음 명령를 이용하여 비밀번호를 확인합니다.

```bash
kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server \
    -o name | cut -d'/' -f 2
# argocd-server-6766455855-pzdrv    --> 비밀번호
```

ArgoCD를 설치하여 로그인하면 가장 먼저 볼 수 있는 화면은 다음과 같습니다. 지금까지 배포된 App의 리스트를 보여주는 화면입니다. 현재는 배포된 App이 없기 때문에 비어있습니다. 새로운 배포를 관장하는 App을 생성해 보기 위해 `New App` 버튼을 누릅니다.

![[그림 15-9] ArgoCD Web UI](15-09.png)

<!-- 단일 진실의 원천을 설정하는 화면 (Git 설정화면) 입니다. -->

다음과 같이 단일 진실의 원천을 설정해 봅시다.

<!-- ![[그림 15-10] Git 설정화면](15-10.png) -->

- `Application Name`: Application의 이름을 지정합니다.
- `Project`: 프로젝트를 선택하는 필드입니다. 쿠버네티스의 네임스페이스와 비슷한 개념으로 여러 App을 논리적인 project로 구분하여 관리할 수 있습니다.
- `Sync Policy`: Git 저장소의 변경 사항을 어떻게 sync할지 결정합니다. Auto는 자동으로 Git 저장소의 변경사항을 운영에 반영하고 Manual은 사용자가 버튼 클릭을 통해  운영 반영을 해줘야 합니다.
- `Repository URL`: ArgoCD가 바라볼 단일 진실의 원천 Git 저장소를 지정합니다.
- `Revision`: Git의 어떤 revision(HEAD, master branch 등)을 바라 볼지 결정합니다.
- `Path`: Git 저장소에서 어떤 디렉토리를 바라볼지 결정합니다. dot(.)인 경우 root path를, 디렉토리 이름을 적으면 해당 디렉토리의 YAML 정의서만 배포합니다.
- `Cluster`: 쿠버네티스 클러스터 지정합니다. 복수의 클러스터를 운영할 때 유용합니다.
- `Namespace`: 클러스터 내 네임스페이스를 지정합니다.
- `Directory Recurse`: Path 아래의 디렉토리를 재귀적으로 트래킹할지를 결정합니다(디렉토리 아래 또 디렉토리가 있는 경우).

## ArgoCD 배포

마찬가지로 앞에서 배포한 `gitops-get-started` 레포지토리를 ArgoCD에서도 원천으로 사용해 봅시다.

- `Application Name`: gitops-get-started
- `Project`: default
- `Sync Policy`: Manual
- `Repository URL`: `https://github.com/hongkunyoo/gitops-get-started.git`
- `Revision`: HEAD
- `Path`: .
- `Cluster`: in-cluster
- `Namespace`: default
- `Directory Recurse`: Unchecked

`CREATE` 버튼을 누른 이후 App이 생성됩니다. App의 `SYNC` 버튼을 누르면 다음과 같이 nginx `Service`와 `Pod`가 생성된 것을 UI로 확인하실 수 있습니다.

![[그림 15-11] Application 연결](15-11.png)

`App Details` 버튼을 누르거나 각 리소스UI를 클릭하시면 더 자세한 내용들을 직접 볼 수 있습니다.

![[그림 15-12] App 상세 화면](15-12.png)

앞서 App을 설정할 때 `sync-policy`를 `Manual`로 설정하였습니다. 아래에 `Auto-Sync` 버튼을 활성화하게 되면 `Automatic`이 되어 매번 사람이 직접 변경사항을 ArgoCD에게 알릴 필요 없이 ArgoCD가 주기적으로 Git 레포지터리의 변경사항을 확인하여 변경된 부분을 적용하게 됩니다. 이때 2가지 옵션을 추가적으로 줄 수 있습니다.

- `Prune Resources`: 변경 사항에 따라 리소스를 업데이터할 때, 기존의 리소스를 삭제하고 새로운 리소스를 생성합니다. Job 리소스처럼 매번 새로운 작업을 실행해야 하는 경우 이 옵션을 사용합니다.
- `Self Heal`: 운영 환경의 리소스가 어떠한 이유로 삭제되었을 때, ArgoCD가 git 레포지토리의 값과 운영 환경의 값을 비교하여 삭제된 리소스를 다시 생성하는 기능입니다. (자가 치유)

ArgoCD를 통해서 원천의 YAML 정의서를 운영 환경에 배포하는 방법에 대해 살펴봤습니다.

### Clean up

```bash
kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl delete ingress argocd -n argocd
kubectl delete deploy mynginx
kubectl delete svc mynginx
```

## 개발 클러스터 배포

#### skaffold 설치

`skaffold`는 단일 실행파일 하나만 다운받으면 설치가 완료됩니다.

```bash
curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
sudo install skaffold /usr/local/bin/
```

### 15.4.2 skaffold 세팅

`skaffold`를 사용하기 위해서 먼저 개발 스크립트(`app.py`), 빌드에 사용할 도커파일(`Dockerfile`), 배포에 사용할 YAML 배포 정의서(`pod.yaml`)가 각각 1개씩 필요합니다.

- 스크립트 파일

```python
# app.py
from flask import Flask
app = Flask(__name__)


@app.route('/')
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()
```

- 도커파일

```Dockerfile
# Dockerfile
FROM python:3.7

RUN pip install flask
ADD app.py .

ENTRYPOINT ["python", "app.py"]
```

- YAML 정의서

```yaml
# pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: skaffold-flask
spec:
  containers:
  - image: <USERNAME>/flask   # 각 사용자 docker hub 계정을 입력합니다.
    name: flask
```

-LINE_SPLITTER-

```bash
ls
# app.py    Dockerfile    pod.yaml
```

그리고 나서 `skaffold init` 명령을 실행하면 `skaffold.yaml` 이라는 파일이 생성됩니다. 해당 명령 실행 시 디렉토리 안에 앞에서 생성한 3가지 파일 외엔 다른 파일이 있으면 안됩니다.

```bash
skaffold init
# apiVersion: skaffold/v2beta5
# kind: Config
# metadata:
#   name: some-directory
# build:
#   artifacts:
#   - image: <USERNAME>/flask
# deploy:
#   kubectl:
#     manifests:
#     - pod.yaml
# 
# Do you want to write this configuration to skaffold.yaml? [y/n]: y
# Configuration skaffold.yaml was written

ls 
# app.py    Dockerfile    pod.yaml    skaffold.yaml
```

- `apiVersion`: `skaffold.yaml` 파일도 쿠버네티스의 리소스 정의서와 같이 api버전을 정의합니다.
- `kind`: `skaffold`의 `Config` 리소스인 것을 명시합니다.
- `metadata.name`: `skaffold`의 이름을 정의합니다. 디렉토리 이름이 사용됩니다.
- `build.artifacts`: 이미지 빌드 결과물을 설정합니다. `pod.yaml`에서 정의된 이미지 주소가 적혀있습니다.
- `deploy.kubectl.manifests`: 배포에 사용할 배포 정의서(YAML)가 지정되어 있습니다.

자동 배포를 수행하기 전에 먼저 도커허브 credential이 저장되어 있는지 확인합니다.

```bash
docker login
# Login with your Docker ID to push and pull images from Docker Hub. ..
# Username: <USERNAME>
# Password:
# WARNING! Your password will be stored unencrypted in ...
# Configure a credential helper to remove this warning. See
# https://docs.docker.com/engine/reference/commandline/...
# 
# Login Succeeded
```

### 15.4.3 skaffold를 이용한 배포

`skaffold`를 이용하여 배포를 수행해 봅시다. 다음과 같이 입력하면 `skaffold`가 자동으로 이미지 빌드부터 푸시, 배포까지 자동으로 수행합니다.

```bash
skaffold run
# Generating tags...
#  - <USERNAME>/flask -> <USERNAME>/flask:latest
# Some taggers failed. Rerun with -vdebug for errors.
# ...
```

default 네임스페이스의 `Pod`를 지켜보고 있으면 자동으로 `skaffold-flask` `Pod`가 생성되는 것을 확인할 수 있습니다. 이렇게 `skaffold run` 명령 하나만으로 편리하게 쿠버네티스 개발을 수행할 수 있습니다.

```bash
kubectl get pod
# NAME             READY   STATUS              RESTARTS   AGE
# skaffold-flask   0/1     ContainerCreating   0          2m21s
```

`--tail` 옵션을 사용하면 `Pod` 로깅까지 자동으로 연결해주기 때문에 사용자가 직접 `kubectl logs`를 따로 실행하지 않아도 됩니다.

```bash
# 기존 pod 삭제
kubectl delete pod skaffold-flask
# pod "skaffold-flask" deleted

skaffold run --tail
# ...
# Press Ctrl+C to exit
# [skaffold-flask flask] starting app
# [skaffold-flask flask]  * Serving Flask app "app" (lazy loading)
# [skaffold-flask flask]  * Environment: production
# [skaffold-flask flask]    WARNING: This is a development server. Do not 
#                                  use it in a production deployment.
# [skaffold-flask flask]    Use a production WSGI server instead.
# [skaffold-flask flask]  * Debug mode: off
# [skaffold-flask flask]  * Running on http://127.0.0.1:5000/ 
#                                  (Press CTRL+C to quit)
```

마지막으로 `skaffold dev`를 실행하면 기본적으로 `skaffold run`과 동일하지만 소스코드나 도커 파일을 수정하게 되면 변경 사항을 인지하고 자동으로 다시 빌드부터 배포까지 수행합니다.

```bash
# 기존 pod 삭제
kubectl delete pod skaffold-flask
# pod "skaffold-flask" deleted

skaffold dev
```

---

**![참고](info.png) 참고** 

`skaffold dev`를 실행하고 동시에 파일을 수정하기 위해서는 터미널 창을 두 개 열거나 `tmux`나 `screen`과 같은 multiplex terminal 사용하기를 추천드립니다.

---

`skaffold dev`를 실행하고 `app.py`를 일부 수정 후 저장합니다.

```python
from flask import Flask
app = Flask(__name__)


@app.route('/')
def hello():
    return "Hello World!2"

if __name__ == '__main__':
    print('start app')     # print문 추가 후 저장
    app.run()
```

`skaffold`가 변경점을 자동으로 인지하고 다시 처음부터 빌드를 하고 배포를 수행합니다.

```bash
skaffold dev
# ...
# Press Ctrl+C to exit
# [skaffold-flask flask] starting app
# [skaffold-flask flask]  * Serving Flask app "app" (lazy loading)
# [skaffold-flask flask]  * Environment: production
# [skaffold-flask flask]    WARNING: This is a development server. Do not 
#                                  use it in a production deployment.
# [skaffold-flask flask]    Use a production WSGI server instead.
# [skaffold-flask flask]  * Debug mode: off
# [skaffold-flask flask]  * Running on http://127.0.0.1:5000/ 
#                                  (Press CTRL+C to quit)
```

`skaffold dev`는 `CTRL+C`로 중단하면 `Pod` 삭제까지 자동으로 수행됩니다. `skaffold`는 쿠버네티스 개발에 있어서 없어서는 안될 편리한 툴입니다.
